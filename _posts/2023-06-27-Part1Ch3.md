---
title: "Chapter 3: Application Attack Indicators"
date: 2023-06-27 17:00:00 +500
categories: [Security+, Part I]
tags: []    # TAG names should always be lowercase
---
<script>
// Get the container element that holds the post content
var containerElement = document.getElementById('containerElementId');

// Function to save the reading position based on the scroll
function saveReadingPosition() {
  localStorage.setItem('readingPosition', containerElement.scrollTop);
}

// Event listener to update the reading position on scroll
containerElement.addEventListener('scroll', saveReadingPosition);

// Get the saved reading position from local storage
var savedPosition = localStorage.getItem('readingPosition');

// Scroll to the saved reading position
if (savedPosition) {
  containerElement.scrollTop = savedPosition;
}
</script>

<style>
  p {
    text-align: justify;
  }
  #myParagraph {
  display: none;
  pointer-events: none;
}
  </style>

# Part I Threats, Attacks, and Vulnerabilities


## Chapter 3: Application Attack Indicators

### Privilege Escalation


Privilege escalation involves gaining higher levels of access or privileges on computer systems, networks, or applications beyond the initial level. It can occur in various contexts like operating systems, applications, databases, or networks, with the aim of obtaining additional permissions, often administrative or root-level access. This practice is viewed as a security vulnerability or attack vector. Attackers can exploit privilege escalation using techniques like exploiting software vulnerabilities, misconfigurations, weak access controls, or manipulating user interactions to carry out malicious actions.

There are different types of privilege escalation, including:

1. Vertical Privilege Escalation: This involves elevating privileges from a lower level to a higher level within the same user hierarchy. For example, a regular user gaining administrative privileges.

2. Horizontal Privilege Escalation: In this case, the attacker gains the same level of privileges as the target user but assumes the identity of that user. It typically occurs when there are multiple user accounts with the same privilege level but different permissions.

3. Lateral Privilege Escalation: This form of privilege escalation involves gaining privileges within the same level <u>but across different systems or services</u>. It may happen when a compromised account on one system is used to access another system or service with the same or higher privileges.


### Cross-Site Scripting

Is a type of security vulnerability commonly found in web applications. It occurs when an attacker injects malicious scripts or code into a trusted website or web application, which is then executed by a victim's browser. The vulnerability typically arises due to insufficient input validation or sanitization of user-supplied data that is displayed on a web page.

There are three main types of XSS attacks:

1. Stored XSS: The malicious script is permanently stored on the target server and is served to users when they visit a specific web page. This type of XSS attack can impact multiple users who view the compromised content.

2. Reflected XSS: The malicious script is embedded in a URL or a link and is only triggered when a user clicks on that specially crafted link. The injected script is then reflected back in the response, executing in the user's browser.

3. DOM-based XSS: This type of XSS attack occurs when the vulnerability is present in the Document Object Model (DOM) of a web page. The malicious script manipulates the DOM environment, leading to unauthorized actions or information disclosure.

4. Non-persistent XSS: The injected script is not persisted or stored but rather is immediately executed and passed back via the web server.


The consequences of a successful XSS attack can vary, ranging from defacing websites, stealing sensitive information (such as login credentials or personal data), session hijacking, or even spreading malware to unsuspecting users.

Preventing XSS vulnerabilities involves input validation and sanitization of user-supplied data, properly encoding output to prevent script execution, and implementing security mechanisms like Content Security Policy (CSP) to restrict the execution of external scripts. Regular security updates and patches should also be applied to the web application to address any known vulnerabilities.

### Injection Attacks

Injection attacks are a type of security vulnerability where an attacker is able to inject malicious code or commands into a vulnerable system, typically by exploiting input validation or sanitization flaws. The injected code or commands can manipulate the behavior of the system and potentially gain unauthorized access, modify or retrieve sensitive data, or perform unintended actions.

#### Structured Query Language (SQL)

Is a programming language used for managing and manipulating relational databases. It allows users to interact with databases by performing operations such as querying data, inserting, updating, and deleting records. SQL injection is a common type of injection attack where an attacker inserts malicious SQL code into a vulnerable application's input fields, tricking the application into executing unintended SQL commands.

SQL Injection Example:

Let's say we have a website with a login form that accepts a username and password. The website's code uses user-supplied input directly in an SQL query without proper validation or sanitization. The SQL query might look like this:

```sql
SELECT * FROM users WHERE username = '<user-input>' AND password = '<user-input>';
```

Now, imagine a malicious user enters the following in the username field:

```
' OR '1'='1
```

The resulting SQL query after the injection would become:

```sql
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '<user-input>';
```

The injected code `' OR '1'='1` is a Boolean expression that always evaluates to true. By doing this, the attacker bypasses the password check and gains unauthorized access to the system. The query will return all rows from the "users" table, effectively allowing the attacker to log in as any user in the system.

This is a basic example, but SQL injection attacks can become more sophisticated and have severe consequences, such as extracting sensitive information, modifying databases, or executing arbitrary commands on the database server. That's why it's crucial to implement proper input validation, parameterized queries, or prepared statements to prevent SQL injection vulnerabilities.

#### Dynamic-Link Library (DLL)

Is a file containing code and data that can be used by multiple programs simultaneously. DLLs are used in Microsoft Windows operating systems to provide shared functions and resources to different applications. However, DLL injection is a technique used by attackers to inject malicious code into a running process by forcing it to load a malicious DLL file. This technique allows the attacker to gain control over the process and potentially execute unauthorized actions.

DLL Injection Example:

Let's consider a scenario where a legitimate application, called "TargetApp.exe," loads a DLL file to provide additional functionality. The application loads the DLL using a function call, such as `LoadLibrary` or `GetProcAddress`.

An attacker with malicious intent identifies a vulnerability in the TargetApp.exe that allows them to inject their own code into the process. They create a malicious DLL file, called "MaliciousDLL.dll," that contains their code.

The attacker takes advantage of the vulnerability to inject the MaliciousDLL.dll into the running process of TargetApp.exe. The injected DLL gains access to the address space of the process and can execute its code within that context.

Once the MaliciousDLL.dll is successfully injected, it can perform various malicious actions, such as:

1. Keylogging: The DLL can intercept and record keystrokes made by the user within the TargetApp.exe.
2. Credential Theft: The DLL can capture sensitive information, such as login credentials, entered by the user within the TargetApp.exe.
3. System Control: The DLL can modify or manipulate system settings, access files, or execute arbitrary commands within the context of the TargetApp.exe process.
4. Data Theft: The DLL can access and exfiltrate sensitive data from the TargetApp.exe process.


#### Lightweight Directory Access Protocol (LDAP)

Is a widely used protocol for accessing and managing directory information services. Directory information services store and organize data, such as user accounts, organizational structures, and other relevant information. They act as a central repository for managing and retrieving data in a hierarchical format.

Similar to SQL, LDAP provides a standardized approach for querying and modifying data. While SQL is primarily used for relational databases, LDAP is specifically designed for directory services. Both protocols allow users to perform operations such as searching for specific data, adding new entries, modifying existing entries, and deleting entries.

However, just like SQL injection, LDAP injection is a type of attack where an adversary exploits vulnerabilities in the application's handling of user-supplied input. In the case of LDAP injection, the attacker manipulates LDAP queries by inserting malicious input, potentially leading to unauthorized access or disclosure of sensitive information.

LDAP Injection Example:
Assume that username is user and password is pwd in an authentication request. Corresponding LDAP query could be ```(&(Username=user)(Password=pwd))```

An attacker could inject an LDAP query into username field to gain access to the application without providing correct password.

One possible LDAP injection is ```)(&)``` to user name parameter value. The LDAP query with injection will be ```(&(Username=user<b>)(&)</b>)(Password=pwd))```

How does this small injection help in authentication bypass?

* In case of queries like <b>(&(Username=user)(&))(Password=pwd))</b> ; only the first filter i.e, ```(&(Username=user)(&))``` is processed by LDAP server.
* ```(&)``` is absolute true assertion in LDAP. Thus, making the filter ```(&(Username=user)(&))``` always true. An attacker can now access the application without providing correct password.

_Example source: https://compsecurityconcepts.wordpress.com/tag/ldap-injection/_


#### Extensible Markup Language (XML)

Is a markup language that defines rules for encoding documents in a format that is both human-readable and machine-readable. It is widely used for representing structured data and exchanging information between different systems. XML injection, also known as XXE (XML External Entity) injection, is an attack where an attacker injects malicious XML code into an application that parses XML input. This can lead to various security vulnerabilities, including unauthorized data disclosure and denial of service attacks.

XML Injection Example:

Suppose you have a web application that accepts XML input (commonly seen in various types of applications, especially those that involve data exchange, configuration, or messaging) from users and processes it. The application parses the XML and performs certain actions based on its content.

Let's say the application expects XML input in the following format:

```xml
<user>
  <name>John Doe</name>
  <email>john@example.com</email>
</user>
```

The application processes the XML and extracts the user's name and email to perform some operations.

Now, imagine a malicious user submits the following XML input:

```xml
<user>
  <name>John Doe</name>
  <email>john@example.com</email>
  <admin>true</admin>
</user>
```

In this example, the attacker injected an additional `<admin>true</admin>` element within the XML input.

If the application doesn't properly validate or sanitize the XML input, it may blindly trust and act upon the injected `<admin>` element. This could lead to unintended consequences, such as granting administrative privileges to the user or executing unauthorized actions.


### Pointer/Object Dereference

A pointer is a construct that refers to the memory location where a variable is stored, rather than directly holding the value itself. To access the value stored at the memory location pointed to by a pointer, you need to perform a process called dereferencing.

Dereferencing a pointer changes the interpretation of the pointer. Instead of representing the memory location, dereferencing retrieves the actual contents of that memory location. It allows you to work with the value itself, rather than just the memory address.

Pointers can be powerful because they enable efficient operations on a variety of data structures. However, they can also be risky if used incorrectly, as mistakes can lead to unexpected issues. For example, when a programmer combines user input with pointers, it allows the user to select a specific location in an array and use a pointer to reference the value stored there. If there are errors in validating the user input, it can result in mistakes during the pointer dereference process.

Mistakes in pointer dereferencing may or may not trigger an error. The memory location being accessed will contain data, so it will be returned, even if it's not the intended or valid value. This connection between pointers and the objects they reference is referred to as pointer/object dereference.


### Directory Traversal

In a directory traversal attack, an attacker manipulates input to bypass the directory structure of a filesystem. By including special encoded symbols like "../.." in an unchecked input field, the attacker tricks the parser into interpreting the encoding as traversal code. This allows them to navigate to different locations in the filesystem than intended, potentially executing commands in an unauthorized manner. When combined with a command injection vulnerability, this attack can lead to the execution of unauthorized code.

Directory traversal attacks are categorized as input validation errors and can be challenging to detect without thorough code reviews and specific scrutiny. This highlights the importance of using resources like the CWE (Common Weakness Enumeration) Top 25 Most Dangerous Software Errors checklist during code reviews. Such checklists help alert developers to potential issues like directory traversal during the development process.

To make detection more difficult, attackers can mask directory traversals by using input encoding. If the security check is performed before the string is decoded by the system parser, it becomes harder to recognize the attack. There are multiple ways to represent a particular input form, with the canonical form being the simplest example. Parsers are responsible for rendering the canonical form for the operating system, but these embedded parsers may act after input validation, making it challenging to detect certain attacks by simply matching a string.


![Alt text](/assets/secplus/photos/directory-traversal.png)
_Image Source: https://portswigger.net/web-security/file-path-traversal_

### Buffer Overflow

Is a type of software vulnerability that occurs when a program tries to write more data into a buffer (a temporary storage area in memory) than it can handle. This can happen when the size of the input data exceeds the capacity of the buffer.

When a buffer overflow occurs, the extra data spills over into adjacent memory locations, overwriting important information such as return addresses, function pointers, or other variables. This can lead to unexpected behavior and security vulnerabilities.

Attackers can exploit buffer overflow vulnerabilities to execute malicious code or gain unauthorized access to a system. By carefully crafting input data, an attacker can overwrite critical memory structures and take control of the program's execution.

Here's a simplified example to illustrate a buffer overflow vulnerability:

```c
void copyData(char* source) {
    char buffer[8];
    strcpy(buffer, source);
    // ...
}

int main() {
    char input[16];
    // Assume the user provides input larger than 8 characters
    scanf("%s", input);
    copyData(input);
    // ...
    return 0;
}
```

In this example, the `copyData` function receives a source string and tries to copy it into a buffer with a size of 8 characters. However, if the user provides input larger than 8 characters, it will overflow the buffer.

If an attacker supplies input with a length greater than 8 characters, the extra data will overwrite adjacent memory locations beyond the buffer's boundaries. This can lead to unpredictable behavior, including crashing the program or executing malicious instructions.

It's worth noting that modern programming languages and frameworks often include built-in safeguards against buffer overflows, making it less common in well-designed and secure software. However, developers should still be aware of the potential risks and take appropriate precautions when handling user input and managing memory.

### Race Condition

Is a software vulnerability that occurs when the behavior or outcome of a program depends on the sequence or timing of events. It arises when multiple processes or threads access shared resources or perform operations concurrently without proper synchronization or coordination.

In a race condition, the exact order or timing of these concurrent operations becomes unpredictable, leading to unexpected and potentially undesirable results. The outcome of the program becomes dependent on which process or thread "wins the race" to access or modify the shared resource.

Here's a simplified example to illustrate a race condition:

```c
int balance = 100; // Shared variable

void withdraw(int amount) {
    if (balance >= amount) {
        // Simulate some delay
        sleep(1);
        balance -= amount;
        printf("Withdrawal successful. New balance: %d\n", balance);
    } else {
        printf("Insufficient balance\n");
    }
}

// Assume two threads call the withdraw function simultaneously
```

In this example, two threads call the `withdraw` function concurrently, trying to withdraw amounts from a shared `balance` variable. If the balance is sufficient, the thread checks the balance, delays for a second (to simulate some processing), and then deducts the amount from the balance. Otherwise, it prints an "Insufficient balance" message.

However, a race condition can occur if both threads access the shared `balance` variable simultaneously. The following sequence of events can lead to an unexpected outcome:

1. Thread A and Thread B both check the balance and find it to be sufficient.
2. Thread A delays for a second (as per the sleep statement) before deducting the amount.
3. During the delay, Thread B also deducts the amount from the balance.
4. Thread A deducts the amount from the balance, unaware that Thread B has already done the same.
5. The final balance is lower than expected, resulting in a potential inconsistency or incorrect behavior.

Race conditions can cause various issues, including data corruption, incorrect results, crashes, or security vulnerabilities. They can be particularly challenging to identify and reproduce because they depend on the timing and interleaving of concurrent operations.

To prevent race conditions, proper synchronization mechanisms such as locks, semaphores, or atomic operations should be employed to ensure exclusive access to shared resources. By synchronizing the access to critical sections of code or shared data, developers can mitigate race conditions and maintain the correctness and integrity of the program.

#### Time of Check/Time of Use (TOCTOU)

Time of Check/Time of Use (TOCTOU) is a security vulnerability that occurs when there is a gap between checking a condition and using a resource based on that condition. 

Imagine you have a program that checks if a user has permission to access a file before reading its contents. Here's a simplified breakdown:

1. Checking Permissions: The program verifies if the user has the required permissions to access the file. It does this by comparing the user's privileges against the file's permission settings.

2. Time Gap: Between the permission check and the actual file usage, there is a gap of time during which other operations can occur. During this gap, the security context may change, which can affect the permissions of the file.

3. Manipulation: An attacker, aware of this gap, can attempt to manipulate the conditions or resources during this time. They exploit weaknesses or vulnerabilities in the system to gain unauthorized access.

4. Unauthorized Usage: If the attacker successfully manipulates the conditions, they can bypass the permission checks and gain access to the file. This allows them to perform actions they wouldn't have been allowed to do otherwise.

To mitigate TOCTOU vulnerabilities, it's important to reduce the time gap between condition checks and resource usage, use secure coding practices, and validate permissions at the time of resource usage. Regular monitoring and auditing of permissions also help detect any unauthorized changes. By addressing these concerns, we can minimize the risk of unauthorized access and maintain the security of our systems.

### Improper Error Handling


1. **Definition**: Improper Error Handling occurs when an application does not adequately handle errors, exceptions, or unexpected conditions that may arise during its execution.

2. **Causes**: This vulnerability can be caused by various factors, such as coding errors, poor software design, lack of proper testing, or not considering all possible error scenarios during development.

3. **Impact**: The consequences of improper error handling can be severe and can lead to security breaches or application failures. Attackers may exploit these errors to gain unauthorized access, manipulate data, or crash the application, leading to a denial-of-service (DoS) situation.

4. **Examples**: Some examples of improper error handling include:
   - Displaying detailed error messages containing sensitive information, which attackers could use for reconnaissance.
   - Ignoring errors or exceptions without logging or notifying appropriate personnel, making it challenging to identify and address potential security threats.
   - Failing to validate input properly, leading to unexpected behavior or application crashes.
   - Mishandling file operations, resulting in unauthorized access or data leakage.

5. **Prevention**: To mitigate Improper Error Handling vulnerabilities, developers should implement the following best practices:
   - Use meaningful error messages that don't disclose sensitive information and are helpful for troubleshooting.
   - Implement structured exception handling mechanisms to gracefully handle errors and prevent application crashes.
   - Log errors and exceptions appropriately for later analysis and debugging.
   - Validate all user input to ensure it meets the expected format and doesn't cause unexpected errors.
   - Test the application thoroughly under various conditions to identify and fix potential errors.


### Improper Input Handling


1. **Definition**: Improper Input Handling is a vulnerability that occurs when an application does not validate or sanitize user-supplied data before processing it.

2. **Causes**: This vulnerability can result from programming errors, oversight, or inadequate input validation routines. When developers do not properly check and filter incoming data, it can open the door to potential exploitation.

3. **Impact**: The impact of improper input handling can be severe. Attackers may exploit this weakness by providing malicious input to the application, causing it to behave unexpectedly or execute arbitrary code. Common consequences include data breaches, unauthorized access, and system crashes.

4. **Examples**: Some examples of improper input handling include:
   - Lack of input validation: Accepting user input without checking its format or range, leading to potential buffer overflows or injection attacks (e.g., SQL injection, XSS).
   - Failure to sanitize input: Neglecting to remove or escape special characters from user input, which could enable script injection or other forms of code execution.
   - Insufficient data type validation: Not verifying that the input data matches the expected data type, causing unexpected behavior or crashes.
   - Inadequate length or boundary checks: Allowing input that exceeds the expected length, potentially leading to memory-related vulnerabilities.

5. **Prevention**: To prevent Improper Input Handling vulnerabilities, developers should adopt the following best practices:
   - Implement strict input validation routines to ensure that data adheres to expected formats, lengths, and ranges.
   - Sanitize user input to remove or neutralize any potentially dangerous characters before processing it.
   - Utilize parameterized queries and prepared statements to prevent SQL injection attacks.
   - Use proper encoding and escaping mechanisms when displaying user-generated content.
   - Regularly update and patch the application to address known vulnerabilities in libraries or frameworks used for input handling.


### Replay Attacks


1. **How it works**: In a typical replay attack, the attacker captures data packets or messages sent between two legitimate parties during a previous communication session. The data may include authentication tokens, session identifiers, or other sensitive information. The attacker then retransmits these captured data packets to the system, attempting to mimic a legitimate user's actions.

2. **Objective**: The primary goal of a replay attack is to trick the target system into accepting the retransmitted data as genuine, thereby gaining unauthorized access or performing unauthorized actions on the system.

3. **Mitigating factors**: The success of a replay attack depends on various factors, such as the effectiveness of the security measures implemented by the target system and the freshness of the captured data. If the system employs strong security measures like one-time tokens, nonces, or timestamp verification, the likelihood of a successful replay attack decreases.

4. **Common targets**: Replay attacks can be used against various systems and protocols, including network communication, authentication mechanisms, and cryptographic protocols.

5. **Examples**: Some examples of replay attacks include:
   - Network Replay: An attacker intercepts network packets and replays them to gain unauthorized access to a system or execute unauthorized commands.
   - Authentication Replay: An attacker captures authentication tokens or session identifiers and replays them to bypass the authentication process and impersonate a legitimate user.
   - Cryptographic Replay: In cryptographic protocols, an attacker captures encrypted data and replays it to deceive the system and gain access to encrypted resources.

6. **Prevention**: To prevent replay attacks, several countermeasures can be employed, including:
   - Timestamps: Include timestamps in the communication to ensure that messages or packets have not expired.
   - Nonces: Use unique and random values (nonces) that change with each session to make captured data invalid for future use.
   - One-Time Tokens: Generate and use one-time tokens that cannot be reused, making replayed tokens useless.
   - Sequence Numbers: Employ sequence numbers or message counters to detect and reject duplicate or out-of-sequence messages.


#### Session Replay

Session Replay, also known as Session Recording or User Session Replay, is a practice in web application analytics where user interactions with a website or web application are recorded and later replayed for analysis and understanding of user behavior. It involves capturing a user's actions, such as mouse movements, clicks, and keyboard inputs, as well as the corresponding web page content displayed during the session. This data is then used by website owners or developers to gain insights into user experience, identify usability issues, and improve the overall functionality of the site.


1. **Data Collection**: Session Replay tools collect data by recording user interactions in real-time as they navigate through a website. This data includes mouse movements, clicks, form submissions, scrolling behavior, and other on-page actions.

2. **Page Content**: Along with user interactions, Session Replay tools often capture the rendered web page content during the session. This allows website owners to see what users saw at specific points during their visit.

3. **Session Replaying**: After data is collected, website owners or analysts can replay the recorded sessions to visualize exactly how users interacted with the website. This replaying process typically shows a video-like playback of the user's session.

4. **Benefits**: Session Replay provides several benefits for website owners and developers:
   - User Behavior Analysis: It helps understand how users navigate the website, what they interact with, and potential pain points in their journey.
   - Usability Testing: Identifying usability issues, such as confusing user interfaces or broken interactions, that may lead to user frustration.
   - Debugging: It can assist developers in reproducing and diagnosing user-reported issues or errors.
   - Conversion Optimization: Identifying areas of improvement to increase conversions or achieve specific website goals.

5. **Privacy and Security Considerations**: While Session Replay is valuable for website analysis, it raises privacy and security concerns. Session Replay data may contain sensitive information, such as login credentials, credit card details, or personally identifiable information (PII). To address these concerns, organizations must implement appropriate measures like data anonymization, encryption, and compliance with data protection regulations.

6. **User Consent**: In many regions, websites are required to obtain user consent before implementing Session Replay or similar tracking technologies. Transparency about data collection practices is essential to build trust with users.


### Integer Overflow

Integer Overflow is a vulnerability that occurs when a computer program attempts to store a numeric value that is too large for the data type used to represent the value. In programming languages, integers have a fixed range they can represent, based on the number of bits allocated to store them. If an operation results in a value beyond the maximum representable value (overflow) or below the minimum representable value (underflow), the result may wrap around, leading to unexpected and potentially dangerous behavior.

Here's a more detailed explanation of Integer Overflow:

1. **Representation of Integers**: In most programming languages, integers are stored using a fixed number of bits (e.g., 32 or 64 bits). This means there is a maximum and minimum value that can be represented by the data type. For example, a 32-bit signed integer can represent values from -2,147,483,648 to 2,147,483,647.

2. **Cause**: Integer Overflow occurs when a computation or operation results in a value that exceeds the maximum representable value for the given data type. Similarly, an underflow happens when the result falls below the minimum representable value.

3. **Consequences**: Integer Overflow can lead to unexpected and erroneous behavior in software. For example:
   - Wraparound: When the result exceeds the maximum value, the value wraps around to the minimum value for the data type (and vice versa for underflow). This can lead to incorrect calculations or logic errors.
   - Security Vulnerabilities: In some cases, attackers may intentionally trigger integer overflow to manipulate program behavior and potentially gain unauthorized access or execute arbitrary code.

4. **Prevention**: To prevent Integer Overflow vulnerabilities, developers should take the following measures:
   - Use appropriate data types with sufficient range to accommodate the expected values.
   - Implement proper input validation to ensure that user-supplied values are within the acceptable range before performing calculations.
   - Check for potential overflow conditions during computations and handle them gracefully, such as by using larger data types, checking for overflow flags, or utilizing libraries with built-in overflow protection.


### Request Forgery (CSRF)

Request Forgery, also known as Cross-Site Request Forgery (CSRF) or Session Riding, is a type of security vulnerability in web applications. It occurs when an attacker tricks a user's web browser into unknowingly sending unauthorized requests to a vulnerable website on which the user is authenticated. This attack takes advantage of the trust relationship between the user's browser and the target website.

Here's a more detailed explanation of Request Forgery:

1. **Attack Process**: In a CSRF attack, the attacker crafts a malicious web page or email containing a specially-crafted URL or form that points to the target website. The URL or form includes a request that the attacker wants to execute on the user's behalf. This could be actions like changing account settings, making a purchase, or even deleting critical data.

2. **User Context**: The attack works because the user's browser automatically includes any necessary authentication cookies or credentials when making requests to the target website. Since the user is typically logged in to the target website, the forged request appears legitimate to the site, and it processes the request as if the user had initiated it intentionally.

3. **Impact**: CSRF attacks can have significant consequences, depending on the action the attacker forces the user to perform. These may include unauthorized transactions, unauthorized access to sensitive data, or actions that compromise the user's account security.

4. **Example**: Let's consider a simple example. Assume that a vulnerable online banking website has a feature where users can change their email address using a POST request to the URL `https://examplebank.com/account/settings`. An attacker could craft a malicious webpage with a hidden form that automatically submits a request to change the user's email address when the page is loaded, like this:

   ```html
   <html>
   <body onload="document.forms['attackForm'].submit()">
     <form name="attackForm" action="https://examplebank.com/account/settings" method="POST">
       <input type="hidden" name="email" value="attackersemail@example.com" />
     </form>
   </body>
   </html>
   ```

   If a logged-in user visits the attacker's webpage, their browser will send a request to change their email address without their knowledge or consent.

5. **Prevention**: To prevent CSRF attacks, web developers should implement the following best practices:
   - Use Anti-CSRF tokens: Include a unique token in each form or request that verifies the request's legitimacy. The token should be tied to the user's session and checked by the server on each request.
   - Same-Origin Policy: Ensure that browsers enforce the Same-Origin Policy, which restricts scripts running on one website from making requests to another website.
   - Use HTTP methods appropriately: Use HTTP methods like POST for actions that modify server-side data to prevent CSRF attacks via GET requests.



#### Server-Side Request Forgery (SSRF)

Server-Side Request Forgery (SSRF) is a web application security vulnerability that allows an attacker to make unauthorized requests from the server-side. In an SSRF attack, the attacker tricks the vulnerable web application into sending HTTP requests to other internal or external resources on behalf of the server, often bypassing security measures and gaining access to sensitive information or performing actions that should be restricted.

Here's a more detailed explanation of Server-Side Request Forgery (SSRF):

1. **Exploitation**: In an SSRF attack, the attacker typically crafts a malicious request to the vulnerable web application. This request may include a URL or IP address for a resource the attacker wants to access. The server processes this request, and if it doesn't properly validate and restrict the requested resource, it will unwittingly execute the attacker's request on its behalf.

2. **Impact**: The impact of SSRF can be significant, as it allows attackers to perform actions that are normally restricted from external users. Examples of potential SSRF attack scenarios include:
   - Accessing internal resources, such as databases, files, or administration panels, that should not be exposed publicly.
   - Exploiting vulnerable internal services, such as an HTTP service running on localhost, to pivot and attack the internal network.
   - Accessing sensitive data on other external websites or APIs, often leading to information disclosure.

3. **Common Targets**: The following are common targets for SSRF attacks:
   - Internal Services: Any internal service accessible from the server-side can be targeted, such as backend APIs, databases, or other internal applications.
   - Metadata Endpoints: Cloud environments and containerized applications often expose metadata endpoints that, if accessed, can reveal sensitive information about the server's environment.
   - Backend Services: Attacks can be directed at backend services accessible from the server, including AWS Metadata Service, Docker APIs, etc.

4. **Examples**: Here's a simplified example of an SSRF vulnerability in a web application:

   ```python
   import requests

   def get_external_content(url):
       # Insecure code - no proper validation of the URL
       response = requests.get(url)
       return response.text

   def process_user_input(user_input):
       # Process user input and call the get_external_content function
       content = get_external_content(user_input)
       return content
   ```

   In this example, the `process_user_input` function blindly takes user-supplied input and uses it as the URL parameter in the `get_external_content` function, leading to a potential SSRF vulnerability.

5. **Prevention**: To prevent SSRF attacks, web developers should implement the following security measures:
   - Input Validation: Carefully validate and sanitize any user-supplied input before using it as a URL or making requests to external resources.
   - Whitelisting: Implement whitelists of allowed URLs or IP addresses that the server is allowed to access.
   - Firewall Configuration: Configure firewalls and network restrictions to limit server-side requests to specific trusted resources.


#### Cross-Site Request Forgery (CSRF or XSRF)

Cross-Site Request Forgery (CSRF or XSRF) is a type of web application security vulnerability that allows an attacker to force a user's browser to execute malicious actions on a different website where the user is authenticated. This occurs when the victim's browser unknowingly sends a request to the target website, and the website interprets the request as a legitimate action initiated by the victim.

Here's a more detailed explanation of Cross-Site Request Forgery (CSRF):

1. **How it works**: The CSRF attack usually targets authenticated users of a web application. The attacker crafts a malicious web page or email containing a specially-crafted URL or form that points to the target website. When the victim accesses the malicious page (perhaps by clicking a link), their browser automatically sends the request to the target site, including any relevant session cookies or authentication tokens.

2. **User Context**: The attack takes advantage of the fact that the victim's browser automatically includes the necessary authentication credentials (e.g., session cookies) with requests to the target website. As a result, the target website interprets the request as a legitimate action initiated by the victim, not realizing that the request was forged by the attacker.

3. **Impact**: CSRF attacks can lead to unauthorized actions being performed on the target website on behalf of the victim. The consequences of a successful CSRF attack depend on the specific actions the attacker can force the user to perform. For example, if the victim is an authenticated user of an online banking application, the attacker could force the victim's browser to initiate unauthorized transactions on their behalf.

4. **Example**: Here's a simplified example of a CSRF attack:
   - Assume there's a vulnerable online banking website.
   - The attacker crafts a malicious webpage with an embedded HTML form to perform a fund transfer on the banking website. The form's action points to `https://bank.example/transfer`.
   - The form automatically fills in the victim's account number as the transfer recipient and an amount to transfer.
   - The victim, who is logged in to the banking website, visits the attacker's webpage.
   - The victim's browser sends the fund transfer request to the banking website using the victim's authentication cookies, and the banking website processes the request, initiating the unauthorized transfer.

5. **Prevention**: To prevent CSRF attacks, developers should implement the following best practices:
   - Use CSRF Tokens: Include a unique CSRF token in each form or request that verifies the request's legitimacy. The token should be tied to the user's session and checked by the server on each request.
   - Implement Same-Site Cookie Attribute: Set the "SameSite" attribute on cookies to "Strict" or "Lax" to restrict their use in cross-site requests.
   - Verify the Origin or Referer Header: Check the "Origin" or "Referer" header in incoming requests to verify that they originate from the same domain as the server.


### Application Programming Interface (API) Attacks

Application Programming Interface (API) attacks refer to various cybersecurity threats and vulnerabilities that target the APIs used in web and mobile applications. APIs serve as a bridge that enables different software systems to communicate and interact with each other, making them a crucial part of modern application development. However, their exposure to the internet and potential misuse can lead to a variety of attacks. Here are some common API attacks:

1. **API Key Exposure**: Many APIs require authentication using an API key, which acts as a secret token to identify and authorize users or applications. If the API key is exposed or leaked, unauthorized entities can use it to access the API and potentially misuse the services.

2. **Authorization Bypass**: Weak or improper access control mechanisms can lead to authorization bypass attacks. Attackers exploit these vulnerabilities to gain access to functionalities or data they should not have permission to access.

3. **Parameter Manipulation**: By altering the parameters in API requests, attackers attempt to bypass security checks or modify the behavior of the API to their advantage. This can lead to data manipulation or unauthorized actions.

4. **Injection Attacks**: Similar to traditional web applications, APIs can be vulnerable to injection attacks like SQL injection or NoSQL injection. Attackers can craft malicious input to exploit vulnerable API endpoints and access or manipulate data.

5. **Denial-of-Service (DoS) and Distributed DoS (DDoS)**: APIs are susceptible to DoS and DDoS attacks, where attackers flood the API with a high volume of requests to overload the server, causing service disruption or unavailability.

6. **Man-in-the-Middle (MitM)**: If the communication between the client and the API is not properly encrypted and authenticated, attackers can intercept and modify the data transmitted between them, leading to data theft or tampering.

7. **Session Management Issues**: If an API relies on session management, issues such as session fixation or session hijacking can compromise user sessions and lead to unauthorized access.

8. **Replay Attacks**: Attackers can capture and replay legitimate API requests to perform unauthorized actions or access sensitive data.

9. **Improper Error Handling**: If the API returns detailed error messages containing sensitive information, attackers can use this information for reconnaissance and potential exploitation.

10. **Versioning Issues**: Lack of proper versioning in APIs can lead to security vulnerabilities when updates or changes are made without considering backward compatibility.



### Resource Exhaustion

Resource Exhaustion, also known as Denial-of-Service (DoS), is a type of cyber attack that aims to overwhelm a target system's resources, making it unavailable to legitimate users. The attacker's goal is to exhaust or deplete critical resources, such as processing power, memory, network bandwidth, or disk space, causing the system to become slow or unresponsive or even crash entirely.

There are different forms of Resource Exhaustion attacks, including:

1. **Distributed Denial-of-Service (DDoS)**: In DDoS attacks, multiple compromised computers (botnets) are coordinated to flood the target system with an overwhelming amount of traffic. This flood of requests consumes the target's resources, making it inaccessible to legitimate users.

2. **Connection Exhaustion**: The attacker opens a large number of connections to a server or service, exhausting its ability to accept new connections from legitimate users.

3. **Bandwidth Consumption**: Attackers generate a massive amount of traffic directed at the target, consuming all available bandwidth and causing network congestion.

4. **Memory Exhaustion**: The attacker sends specially crafted requests that allocate excessive memory on the server, depleting available memory resources.

5. **CPU Exhaustion**: The attacker sends complex or resource-intensive tasks to the server, using up all the CPU processing power and leaving little or no capacity for legitimate users.

6. **Disk Space Exhaustion**: Attackers flood the target system with large volumes of data or unnecessary files, filling up the disk space and causing the system to crash or become unresponsive.

7. **Thread/Process Exhaustion**: By creating a large number of threads or processes, the attacker consumes all available system resources and disrupts normal operation.

The consequences of a successful Resource Exhaustion attack can be severe, leading to downtime, financial losses, reputation damage, and potential security risks. To mitigate Resource Exhaustion attacks, organizations can implement various preventive measures:

- Implementing rate limiting and traffic filtering to detect and block abnormal or suspicious traffic patterns.
- Employing Intrusion Detection/Prevention Systems (IDS/IPS) to identify and respond to attack patterns.
- Using load balancers and caching mechanisms to distribute traffic efficiently and handle surges.
- Regularly monitoring and analyzing system performance to detect anomalies and signs of potential attacks.
- Ensuring software and systems are up-to-date with the latest security patches to prevent known vulnerabilities that attackers might exploit.


### Memory Leak

A Memory Leak is a type of software issue that occurs when a program does not properly manage its allocated memory, leading to an unintended and continuous consumption of memory resources over time. In other words, memory that is allocated during program execution is not deallocated or released when it is no longer needed, causing a gradual increase in the program's memory usage.

Here's a more detailed explanation of Memory Leak:

1. **Cause**: Memory leaks are typically the result of programming errors or oversight. They happen when a program dynamically allocates memory (e.g., using functions like `malloc` in C/C++ or `new` in other languages) but fails to release that memory after it is no longer required.

2. **Accumulation of Memory**: As the program runs and the memory leak persists, the program's memory usage keeps increasing. If the program continues to run for an extended period without addressing the memory leak, it may consume all available memory, leading to performance issues, crashes, or even system instability.

3. **Common Causes**: Memory leaks can occur due to various reasons, including:
   - Forgetting to free dynamically allocated memory after its purpose has been served.
   - Mishandling pointers or references, leading to memory not being deallocated correctly.
   - Circular references in certain data structures that prevent memory from being freed.

4. **Impact**: The impact of a memory leak depends on the size of the leak and the length of time the program runs. In the short term, a small memory leak may not be noticeable. However, if the program is long-running or runs frequently (e.g., server applications), memory leaks can accumulate and degrade system performance, leading to slow response times, increased CPU usage, and eventual crashes.

5. **Detection and Debugging**: Detecting memory leaks can be challenging. Memory profiling tools and debugging utilities can help identify memory leaks by tracking memory allocation and deallocation. Developers can use tools like Valgrind (for C/C++), LeakCanary (for Android), and other memory analysis tools in various programming languages to identify and fix memory leaks.

6. **Prevention**: To prevent memory leaks, developers should follow best practices for memory management, such as:
   - Always free dynamically allocated memory after its use.
   - Use smart pointers and garbage collection mechanisms to manage memory automatically (depending on the programming language used).
   - Adopt good coding practices to avoid circular references and memory leaks caused by reference cycles.


### Secure Sockets Layer (SSL) Stripping

SSL Stripping, also known as SSL Downgrade Attack or HTTPS Stripping, is a type of man-in-the-middle (MitM) attack where an attacker intercepts secure communications between a client and a server and downgrades the connection from HTTPS (SSL/TLS-encrypted) to HTTP (unencrypted). The attacker then relays the traffic between the client and the server without the encryption, effectively making the communication vulnerable to eavesdropping and tampering.

Here's a more detailed explanation of SSL Stripping:

1. **How it works**: SSL Stripping attacks occur when a user attempts to access a secure website (HTTPS) using their web browser. The attacker sits between the user and the server, intercepting the initial HTTPS request.

2. **Downgrade to HTTP**: The attacker then responds to the client with a forged response, pretending to be the server, and indicating that the server does not support HTTPS. The attacker downgrades the connection to HTTP by modifying the response headers. The user's browser, seeing that the server does not support HTTPS, proceeds to communicate with the attacker over an unencrypted HTTP connection.

3. **Relaying Traffic**: The attacker establishes a separate, encrypted connection with the actual server on the user's behalf. The user's unencrypted HTTP requests are then relayed to the server by the attacker. Similarly, the server's responses are intercepted and sent back to the user over the unencrypted HTTP connection.

4. **Impact**: By downgrading the secure HTTPS connection to an unencrypted HTTP connection, SSL Stripping allows the attacker to view, modify, or steal sensitive information transmitted between the client and the server. This could include login credentials, session tokens, personal data, and other sensitive information.

5. **Prevention**: To prevent SSL Stripping attacks, website owners and developers should implement the following security measures:
   - Use HTTP Strict Transport Security (HSTS): HSTS is a web security policy mechanism that instructs browsers to only connect to a website over HTTPS, even if the user initially enters HTTP in the URL. This helps prevent SSL Stripping by forcing encrypted connections.
   - Implement HTTP Public Key Pinning (HPKP): HPKP helps prevent attackers from replacing valid SSL certificates with their forged ones by pinning the certificate's public key in the browser.
   - Educate Users: Users should be educated about the importance of looking for the "HTTPS" indicator in the URL and being cautious when accessing websites over unsecured connections.


### Driver Manipulation

Driver Manipulation refers to the act of altering or tampering with device drivers, which are software components that enable communication between hardware devices and the operating system. Driver manipulation can have both legitimate and malicious purposes, depending on the intent of the person performing the manipulation.

1. **Legitimate Driver Manipulation**: In some cases, driver manipulation is done for valid reasons, such as:
   - Driver Development: Developers modify or update device drivers to improve hardware compatibility, enhance performance, or fix bugs and vulnerabilities.
   - Reverse Engineering: Researchers may analyze drivers to understand their inner workings or identify potential security issues.
   - Patching: Users might modify drivers to add custom features, enable hardware not officially supported, or work around specific issues.

2. **Malicious Driver Manipulation**: On the other hand, driver manipulation can also be carried out with malicious intent:
   - Driver Exploitation: Attackers may modify device drivers to introduce vulnerabilities or backdoors into the system. These manipulated drivers can then be used to gain unauthorized access, execute code, or perform other malicious activities.
   - Rootkits: Malware authors might manipulate drivers to hide their presence or activities from security tools and the operating system, creating rootkits that are difficult to detect.
   - Unauthorized Access: Manipulating drivers can allow attackers to bypass security mechanisms, gain escalated privileges, or control hardware devices maliciously.

3. **Kernel-Mode Vulnerabilities**: Manipulating drivers is particularly concerning because drivers typically run in kernel mode, giving them extensive privileges to access hardware and interact with the operating system. An attacker with control over a compromised driver can have deep system-level access.

4. **Prevention and Mitigation**: To prevent and mitigate malicious driver manipulation, several measures can be taken:
   - Code Signing: Authenticode signatures can be used to verify the integrity and authenticity of drivers, ensuring they come from legitimate sources.
   - Secure Boot: Secure Boot mechanisms help prevent the loading of unauthorized or modified drivers during the boot process.
   - Regular Updates: Keeping device drivers up-to-date helps ensure that any known vulnerabilities or weaknesses are patched.
   - Antivirus and Security Software: Employing robust security software can help detect and remove malicious drivers from the system.
   - Proper Privilege Separation: Ensuring that drivers have the necessary access rights and are isolated from user-mode processes can help limit the potential impact of driver manipulation.


#### Shimming

Shimming, in the context of software and systems, refers to a technique used to modify or extend the behavior of an existing component without altering its original source code. Shims act as a middle layer between the component being shimmed and the rest of the system, providing a way to intercept calls and modify or redirect their execution. Shimming is often used for compatibility, security, or performance reasons.

Here's a more detailed explanation of shimming:

1. **Compatibility**: One common use of shimming is to provide backward compatibility for older software or components that may not work correctly with newer systems. Shims can intercept calls to older APIs or system functions and translate them into compatible calls for the updated environment.

2. **Security**: Shimming can also be employed as a security measure to add an extra layer of protection or to mitigate potential security vulnerabilities. Shims can intercept and validate input or data before passing it to the original component, helping to prevent malicious inputs from reaching critical parts of the system.

3. **Performance**: Shimming can optimize the performance of certain components by intercepting and optimizing function calls. For example, shims can be used to cache results or optimize data access to reduce latency and improve overall system performance.

4. **Types of Shims**:
   - **API Shims**: These intercept calls to APIs (Application Programming Interfaces) and translate them for compatibility or security reasons.
   - **DLL Shims**: In Windows systems, DLL (Dynamic Link Library) shims intercept calls to specific DLLs, allowing redirection or modification of their behavior.
   - **Kernel Shims**: In the context of operating systems, kernel shims modify the behavior of kernel functions or drivers without altering their source code.

5. **Implementation**: Shims are typically implemented as a separate layer or a dynamic link library that gets loaded into the application's memory space. When an application makes a specific function call, the shim intercepts the call, performs its intended operation, and then forwards the call to the original function or a modified version of it.

6. **Compatibility Considerations**: While shimming can be useful, it's essential to use them judiciously and carefully test their impact on the system. Overuse of shims can lead to complexities and may introduce new compatibility or security issues.


#### Refactoring

Refactoring is a disciplined technique used in software development to improve the internal structure, design, and overall quality of code without changing its external behavior. It involves making changes to the codebase to enhance readability, maintainability, and extensibility while preserving the existing functionality.

Here's a more detailed explanation of refactoring:

1. **Purpose**: The primary purpose of refactoring is to make code easier to understand and work with, reducing technical debt, and ensuring that the software remains flexible and adaptable to future changes.

2. **When to Refactor**: Refactoring is an ongoing process that can be performed at any stage of the software development life cycle. However, it is often done during regular code reviews, when adding new features, or fixing bugs. It is best practice to refactor continuously to avoid accumulating technical debt.

3. **Techniques**: Refactoring involves a series of small, focused, and intentional code changes. Some common refactoring techniques include:
   - Extract Method: Breaking down a complex method into smaller, more manageable sub-methods.
   - Rename: Giving meaningful names to variables, functions, or classes to improve code readability.
   - Merge Methods: Combining similar or duplicated methods into a single one to eliminate redundancy.
   - Split Class: Splitting a large class into smaller, more focused classes with distinct responsibilities.
   - Remove Dead Code: Eliminating unused or unnecessary code to improve maintainability.

4. **Automated Refactoring Tools**: Many Integrated Development Environments (IDEs) and code editors provide built-in or third-party automated refactoring tools that assist developers in applying common refactorings easily.

5. **Testing during Refactoring**: Refactoring should be done with confidence, knowing that existing tests will ensure that the code continues to behave correctly. Automated unit tests play a crucial role in providing this safety net during refactoring.

6. **Benefits**: Properly refactored code offers several benefits:
   - Improved Code Quality: Code becomes more organized, modular, and readable, making it easier to understand and maintain.
   - Reduced Bugs: By simplifying and clarifying the code, potential bugs and errors are more likely to be discovered and fixed early.
   - Increased Productivity: Refactoring helps developers work more efficiently, as clean and well-structured code is easier to extend and modify.

7. **Refactoring vs. Optimization**: Refactoring focuses on improving code quality and maintainability without affecting functionality. Optimization, on the other hand, aims to improve performance but may involve changes to the code that affect behavior.



### Pass the Hash


"Pass the Hash" (PtH) is a hacking technique used in cybersecurity attacks to gain unauthorized access to computer systems or networks. It involves capturing and reusing hashed user credentials instead of attempting to crack the passwords themselves. This technique takes advantage of the way authentication works in certain systems and is often associated with Windows environments.

Here's a more detailed explanation of "Pass the Hash":

1. **Hashed Passwords**: In many authentication systems, passwords are not stored in their plain text form. Instead, they are hashed, meaning they are transformed into fixed-length strings of characters using a one-way mathematical function. Hashing is designed to be irreversible, making it difficult to retrieve the original password from the hash.

2. **Authentication Process**: When a user attempts to log in to a system, the password they provide is hashed, and the resulting hash is compared to the stored hash of their password on the system. If the hashes match, the user is granted access.

3. **The Attack**: In a "Pass the Hash" attack, an attacker gains access to a computer system or network and manages to extract the hashed password (or "hash") of a user who has administrative privileges or high-level access. The attacker does not need to know the actual password; they only need the hash.

4. **Reusing the Hash**: With the hashed password in hand, the attacker can pass this hash directly to the authentication process, effectively "passing the hash" instead of providing the actual password. If the system does not have robust security measures in place to prevent PtH attacks, it may accept the hash as a valid credential, granting the attacker access with the privileges of the compromised user.

5. **Mitigation**: To protect against "Pass the Hash" attacks, several security measures can be implemented, including:
   - Strong Password Policies: Encouraging users to have strong and unique passwords reduces the likelihood of successful hash capture.
   - Limiting Privileges: Minimizing the number of accounts with administrative privileges reduces the impact of a successful attack.
   - Multi-Factor Authentication (MFA): Implementing MFA can add an extra layer of security, making it more challenging for attackers to misuse hashed credentials.
   - Credential Guard: In Windows environments, Credential Guard is a security feature that helps protect against PtH attacks by storing credentials in a secure isolated container.

Overall, "Pass the Hash" is a potent attack technique that underscores the importance of robust authentication and security practices to protect against unauthorized access to sensitive systems and data.

### Chapter Review



1. Privilege Escalation: The act of gaining higher access privileges on a system than originally intended, often exploited by attackers to perform unauthorized actions.

2. Cross-Site Scripting (XSS): A web application vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users.

3. Injection Attacks: Attacks that exploit vulnerabilities in input validation to insert malicious code into applications or databases.

4. Structured Query Language (SQL): A language used to interact with databases, commonly targeted in injection attacks.

5. Dynamic-Link Library (DLL): Shared libraries in Windows systems that can be manipulated by attackers to load malicious code.

6. Lightweight Directory Access Protocol (LDAP): A protocol used to access and modify directory services, often targeted for unauthorized access.

7. Extensible Markup Language (XML): A markup language commonly used in web services, susceptible to injection and parsing attacks.

8. Pointer/Object Dereference: An attack that exploits memory pointers or object references to gain unauthorized access to data or execute malicious code.

9. Directory Traversal: An attack that exploits file path manipulation to access files and directories outside the intended scope.

10. Buffer Overflow: An attack that overwhelms a program's buffer, causing it to write data beyond its allocated space and potentially execute arbitrary code.

11. Race Condition: An issue that occurs when the outcome of a program depends on the timing of events, often exploited to gain unauthorized access.

12. Time of Check/Time of Use (TOCTOU): An attack that exploits a time gap between the checking and usage of a resource, leading to unauthorized actions.

13. Improper Error Handling: A vulnerability where error messages reveal sensitive information, aiding attackers in their exploits.

14. Improper Input Handling: A vulnerability that arises from inadequate validation and handling of user inputs, leading to exploitation.

15. Replay Attacks: Attacks where intercepted data is replayed to perform unauthorized actions.

16. Session Replay: A specific form of replay attack targeting session data to impersonate a legitimate user.

17. Integer Overflow: A vulnerability that occurs when an integer value exceeds its maximum limit, leading to unexpected behavior.

18. Request Forgery: An attack where unauthorized requests are made on behalf of a user without their knowledge.

19. Server-Side Request Forgery (SSRF): A specific type of request forgery that targets the server's internal resources.

20. Cross-Site Request Forgery (CSRF): An attack where a user is tricked into unknowingly submitting requests to a different website.

21. Application Programming Interface (API) Attacks: Various threats targeting APIs used in web and mobile applications.

22. Resource Exhaustion: Attacks that aim to overwhelm a system's resources, causing unavailability to legitimate users.

23. Memory Leak: A software issue where memory resources are not properly released, leading to performance degradation.

24. Secure Sockets Layer (SSL) Stripping: An attack that downgrades secure HTTPS connections to unencrypted HTTP, facilitating eavesdropping.

25. Driver Manipulation: Tampering with device drivers to gain unauthorized access or introduce vulnerabilities.

26. Shimming: A technique to modify or extend software behavior without altering its original source code.

27. Refactoring: The process of improving code structure and quality without changing its external behavior.

28. Pass the Hash: A technique where attackers reuse captured hashed passwords to gain unauthorized access.



### Chapter questions

<p id="myParagraph">[Link to a page]({% link assets/quiz.html %})</p>



<div style="display: flex; flex-direction: column; height: 60vh;">
  <iframe src="/assets/quiz.html?json=/assets/part1chapter3.json" style="flex: 1;"></iframe>
</div>
